# Flexible Sliding Window
There are 3 types of flexible sliding window problems:
1. find longest subarray (maximum length of a substring/subarray)
2. find shortest subarray (minimum length of a substring/subarray)
3. find "optimal" subarray
# [灵神](https://leetcode.cn/discuss/post/3578981/ti-dan-hua-dong-chuang-kou-ding-chang-bu-rzz7/)

## Flexible Sliding Window Basis (longest subarray)
### template
#### Not using hash set
1. into window
2. while invalid
	1. out of window (shrink window till it's valid)
3. update res
#### Using hash set:
1. out of window (shrink window till it's valid)
2. into window
3. update res

| #   | Difficulty                                      | Problems                                                                                                                                        |                          |                                 |
| --- | ----------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ | ------------------------------- |
| 1   | <span style="color: orange;">Medium</span>      | [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)              | #flexible-sliding-window | <input type="checkbox" checked> |
| 2   | <span style="color: green;">Easy</span> 1329    | [3090. Maximum Length Substring With Two Occurrences](https://leetcode.com/problems/maximum-length-substring-with-two-occurrences/)             | #flexible-sliding-window | <input type="checkbox" checked> |
| 3   | <span style="color: orange;">Medium</span> 1423 | [1493. Longest Subarray of 1's After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/)    | #flexible-sliding-window | <input type="checkbox" checked> |
| 4   | <span style="color: orange;">Medium</span> 1497 | [1208. Get Equal Substrings Within Budget](https://leetcode.com/problems/get-equal-substrings-within-budget/)                                   | #flexible-sliding-window | <input type="checkbox" checked> |
| 5   | <span style="color: orange;">Medium</span> 1516 | [904. Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/)                                                                    | #flexible-sliding-window | <input type="checkbox" checked> |
| 6   | <span style="color: orange;">Medium</span> 1529 | [1695. Maximum Erasure Value](https://leetcode.com/problems/maximum-erasure-value/)                                                             | #flexible-sliding-window | <input type="checkbox" checked> |
| 7   | <span style="color: orange;">Medium</span> 1535 | [2958. Length of Longest Subarray With at Most K Frequency](https://leetcode.com/problems/length-of-longest-subarray-with-at-most-k-frequency/) | #flexible-sliding-window | <input type="checkbox" checked> |
| 8   | <span style="color: orange;">Medium</span> 1643 | [2024. Maximize the Confusion of an Exam](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/)                                     | #flexible-sliding-window | <input type="checkbox" checked> |
| 9   | <span style="color: orange;">Medium</span> 1656 | [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)                                                       | #flexible-sliding-window | <input type="checkbox" checked> |
| 10  | <span style="color: orange;">Medium</span> 1817 | [1658. Minimum Operations to Reduce X to Zero](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/)                           | #flexible-sliding-window | <input type="checkbox" checked> |
### [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
We should remove and update left while we found a visited char, I made a mistake on thinking about removing till `left == right` -> `while s[left] != s[right]`.
```python
# Input: s = "abcabcbb"
# Output: 3
# Explanation: The answer is "abc", with the length of 3.
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        n = len(s)
        left = res = window = 0
        visited = set()
        for right in range(n):
            while s[right] in visited:
                visited.remove(s[left])
                window -= 1
                left += 1
            visited.add(s[right])
            window += 1
            res = max(res, window)
        return res
```
### [3090. Maximum Length Substring With Two Occurrences](https://leetcode.com/problems/maximum-length-substring-with-two-occurrences/)
```python
# Input: s = "bcbbbcba"
# Output: 4
# Explanation:
# The following substring has a length of 4 and contains at most two occurrences of each character: `"bcbbbcba"`.
class Solution:
    def maximumLengthSubstring(self, s: str) -> int:
        n = len(s)
        left = res = 0
        visited = Counter()
        for right in range(n):
            # into window
            visited[s[right]] = visited.get(s[right], 0) + 1
            # out of window, update left
            while visited.get(s[right], 0) > 2:
                visited[s[left]] = visited.get(s[left], 0) - 1
                left += 1
            # update res
            res = max(res, right - left + 1)
        return res
```
### [1493. Longest Subarray of 1's After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/)
#### Idea
1. keep track of num of 0s
2. move left when num of 0 > 1
3. update res
```python
# Input: nums = [1,1,0,1]
# Output: 3
# Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.

# Input: nums = [0,1,1,1,0,1,1,0,1]
# Output: 5
# Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].

# Input: nums = [1,1,1]
# Output: 2
# Explanation: You must delete one element.
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        n = len(nums)
        zero_count = left = res = 0
        for right in range(n):
            if nums[right] == 0:
                zero_count += 1
            while zero_count > 1:
                if nums[left] == 0:
                    zero_count -= 1
                left += 1
            # it is right - left instead of right - left + 1 because
            # there's a 0 in between right and left
            res = max(res, right - left)
        return res
```
### [1208. Get Equal Substrings Within Budget](https://leetcode.com/problems/get-equal-substrings-within-budget/)
```python
# Input: s = "abcd", t = "bcdf", maxCost = 3
# Output: 3
# Explanation: "abc" of s can change to "bcd".
# That costs 3, so the maximum length is 3.

# Input: s = "abcd", t = "cdef", maxCost = 3
# Output: 1
# Explanation: Each character in s costs 2 to change to character in t,  so the maximum length is 1.

# Input: s = "abcd", t = "acde", maxCost = 0
# Output: 1
# Explanation: You cannot make any change, so the maximum length is 1.
class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        n = len(s)
        left = res = cost = 0
        for right in range(n):
            # into window
            cost += abs(ord(s[right]) - ord(t[right]))
            # out of window
            while cost > maxCost:
                cost -= abs(ord(s[left]) - ord(t[left]))
                left += 1
            # update
            res = max(res, right - left + 1)
        return res
```
### [904. Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/)
```python
# Input: fruits = [1,2,1]
# Output: 3
# Explanation: We can pick from all 3 trees.

# Input: fruits = [0,1,2,2]
# Output: 3
# Explanation: We can pick from trees [1,2,2].
# If we had started at the first tree, we would only pick from trees [0,1].

# Input: fruits = [1,2,3,2,2]
# Output: 4
# Explanation: We can pick from trees [2,3,2,2].
# If we had started at the first tree, we would only pick from trees [1,2].
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        n = len(fruits)
        basket = Counter()
        left = res = 0
        for right in range(n):
            # into window
            basket[fruits[right]] = basket.get(fruits[right], 0) + 1
            # out of window, update left
            while len(basket) > 2:
                basket[fruits[left]] -= 1
                if basket[fruits[left]] == 0:
                    basket.pop(fruits[left])
                left += 1
            # update res
            res = max(res, right - left + 1)
        return res
```
### [1695. Maximum Erasure Value](https://leetcode.com/problems/maximum-erasure-value/)
```python
# Input: nums = [4,2,4,5,6]
# Output: 17
# Explanation: The optimal subarray here is [2,4,5,6].

# Input: nums = [5,2,1,2,5,2,1,2,5]
# Output: 8
# Explanation: The optimal subarray here is [5,2,1] or [1,2,5].
class Solution:
    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        n = len(nums)
        visited = set()
        left = res = window = 0
        for right in range(n):
            # out of window, update left, update window
            while nums[right] in visited:
                visited.remove(nums[left])
                window -= nums[left]
                left += 1
            # into window
            visited.add(nums[right])
            window += nums[right]
            # update res
            res = max(res, window)
        return res
```
### [2958. Length of Longest Subarray With at Most K Frequency](https://leetcode.com/problems/length-of-longest-subarray-with-at-most-k-frequency/)
```python
# Input: nums = [1,2,3,1,2,3,1,2], k = 2
# Output: 6
# Explanation: The longest possible good subarray is [1,2,3,1,2,3] since the values 1, 2, and 3 occur at most twice in this subarray. Note that the subarrays [2,3,1,2,3,1] and [3,1,2,3,1,2] are also good.
# It can be shown that there are no good subarrays with length more than 6.

# Input: nums = [1,2,1,2,1,2,1,2], k = 1
# Output: 2
# Explanation: The longest possible good subarray is [1,2] since the values 1 and 2 occur at most once in this subarray. Note that the subarray [2,1] is also good.
# It can be shown that there are no good subarrays with length more than 2.

# Input: nums = [5,5,5,5,5,5,5], k = 4
# Output: 4
# Explanation: The longest possible good subarray is [5,5,5,5] since the value 5 occurs 4 times in this subarray.
# It can be shown that there are no good subarrays with length more than 4.
class Solution:
    def maxSubarrayLength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        left = res = 0
        freq = Counter()
        for right in range(n):
            # into window
            freq[nums[right]] = freq.get(nums[right], 0) + 1
            # out of window, update left
            while freq[nums[right]] > k:
                freq[nums[left]] -= 1
                if freq[nums[left]] == 0:
                    freq.pop(nums[left])
                left += 1
            # update res
            res = max(res, right - left + 1)
        return res
```
### [2024. Maximize the Confusion of an Exam](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/)
```python
# Input: answerKey = "TTFF", k = 2
# Output: 4
# Explanation: We can replace both the 'F's with 'T's to make answerKey = "TTTT".
# There are four consecutive 'T's.

# Input: answerKey = "TFFT", k = 1
# Output: 3
# Explanation: We can replace the first 'T' with an 'F' to make answerKey = "FFFT".
# Alternatively, we can replace the second 'T' with an 'F' to make answerKey = "TFFF".
# In both cases, there are three consecutive 'F's.

# Input: answerKey = "TTFTTFTT", k = 1
# Output: 5
# Explanation: We can replace the first 'F' to make answerKey = "TTTTTFTT"
# Alternatively, we can replace the second 'F' to make answerKey = "TTFTTTTT". 
# In both cases, there are five consecutive 'T's.
class Solution:
    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:
        n = len(answerKey)
        left = res = 0
        visited = defaultdict()
        for right in range(n):
            # into window
            visited[answerKey[right]] = visited.get(answerKey[right], 0) + 1
            # outof window
            while min(visited.get('T', 0), visited.get('F', 0)) > k:
                visited[answerKey[left]] -= 1
                left += 1
            # update res
            res = max(res, right - left + 1)
        return res

class Solution:
    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:
        # advance improved idea
        # previously, we need to shrink the window size, but this is not necessary,
        # we can keep the max window size we have found (becomes a fixed sliding window),
        # then dequeue the left which is right - res (i - k)
        n = len(answerKey)
        res = 0
        visited = Counter()
        for right in range(n):
            # 1. into window
            visited[answerKey[right]] += 1
            minor = min(visited['T'], visited['F'])
            if minor <= k:
                # 3. update res
                res += 1
            else:
                # 2. update window
                visited[answerKey[right - res]] -= 1
        return res

```
### [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)
Note: this problem can be resolved without following the template to shrink the window and update the result every time.
#### solution with template
```python
# Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
# Output: 6
# Explanation:** [1,1,1,0,0,**1**,1,1,1,1,**1**]
# Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.

# Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
# Output: 10
# Explanation: [0,0,1,1,**1**,**1**,1,1,1,**1**,1,1,0,0,0,1,1,1,1]
# Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        n = len(nums)
        zeros = left = res = 0
        for right in range(n):
            # 1. into window
            if nums[right] == 0:
                zeros += 1
            # 2. shrink window til valid
            while zeros > k:
                if nums[left] == 0:
                    zeros -= 1
                left += 1
            # 3. update res
            res = max(res, right - left + 1)
        return res
```
#### solution without template
```python
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        n = len(nums)
        zeros = left = 0
        for right in range(n):
            if nums[right] == 0:
                zeros += 1
            if zeros > k:
                if nums[left] == 0:
                    zeros -= 1
                left += 1
        return right - left + 1
```
### [1658. Minimum Operations to Reduce X to Zero](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/)
Key note:
The problem ask to 
	find the min num of elements that makes `x = 0`, by taking elements from start and end
this is tricky and not obvious a sliding window problem, 
but it is if we change the problem a bit to
	find the min num of elements that adds up to `Sum(arr) - x`
```python
class Solution:
    def minOperations(self, nums: List[int], x: int) -> int:
        n = len(nums)
        target = sum(nums) - x
        window = left = res = 0
        for right in range(n):
            # into window
            window += nums[right]
            # shrink window till valid
            while left <= right and window > target:
                window -= nums[left]
                left += 1
            # update res
            if window == target:
                res = max(res, right - left + 1)
        # res is the # of elements adds up to sum(nums)
        # we need to return the toal - res for the # of elements makes x = 0
        return -1 if res == 0 else n - res
```

## Flexible Sliding Window Basis (minimum/shortest)
### Template
1. into window
2. while **valid**
	1. update res
	2. shrink window

| #   | Difficulty                                      | Problems                                                                                                                                                  |                          |                                 |
| --- | ----------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ | ------------------------------- |
| 1   | <span style="color: orange;">Medium</span>      | [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)                                                                | #flexible-sliding-window | <input type="checkbox" checked> |
| 2   | <span style="color: orange;">Medium</span>      | [2904. Shortest and Lexicographically Smallest Beautiful String](https://leetcode.com/problems/shortest-and-lexicographically-smallest-beautiful-string/) | #flexible-sliding-window | <input type="checkbox" checked> |
| 3   | <span style="color: orange;">Medium</span> 1878 | [1234. Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/)                               | #flexible-sliding-window | <input type="checkbox">         |
| 4   | <span style="color: orange;">Medium</span> 1914 | [2875. Minimum Size Subarray in Infinite Array](https://leetcode.com/problems/minimum-size-subarray-in-infinite-array/)                                   | #flexible-sliding-window | <input type="checkbox">         |
| 5   | <span style="color: red;">Hard</span>           | [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)                                                                   | #flexible-sliding-window | <input type="checkbox">         |
| 6   | <span style="color: red;">Hard</span>           | [632. Smallest Range Covering Elements from K Lists](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/)                        | #flexible-sliding-window | <input type="checkbox">         |
### [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)
```python
# Input: target = 7, nums = [2,3,1,2,4,3]
# Output: 2
# Explanation: The subarray [4,3] has the minimal length under the problem constraint.

# Input: target = 4, nums = [1,4,4]
# Output: 1

# Input: target = 11, nums = [1,1,1,1,1,1,1,1]
# Output: 0
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        window = left = 0
        res = float('inf')
        for right in range(n):
            # into window
            window += nums[right]
            while window >= target:
                # update res
                res = min(res, right - left + 1)
                # shrink window
                window -= nums[left]
                left += 1
        return 0 if res == float('inf') else res
```
### [2904. Shortest and Lexicographically Smallest Beautiful String](https://leetcode.com/problems/shortest-and-lexicographically-smallest-beautiful-string/)
Note:
on updating the result, because we want the smallest binary, so when the length is the same, we need to compare the binaries.
question remain:
I tried combining the two conditions to always check for min binary, not sure why it does not work, perhaps it's because the initial `res_str` is empty string
```python
class Solution:
    def shortestBeautifulSubstring(self, s: str, k: int) -> str:
        n = len(s)
        left = 0
        min_len = float('INF')
        res_str = ''
        for right in range(n):
            # into window
            k -= int(s[right])
            while k <= 0:
                # update res
                if k == 0:
                    if right - left < min_len:
                        min_len = right - left
                        res_str = s[left:right + 1]
                    # ***pick the smaller binary
                    elif right - left == min_len:
                        min_len = right - left
                        res_str = min(res_str, s[left:right + 1])
                # shrink window
                k += int(s[left])
                left += 1
        return res_str
```