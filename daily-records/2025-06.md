2025-06-01
Sliding Window:
1. [3090. Maximum Length Substring With Two Occurrences](https://leetcode.com/problems/maximum-length-substring-with-two-occurrences/)
	1. hash map to check occurrences
	2. into window
	3. while over max occurrences
		1. left out of window
		2. delete key if 0
	4. update res
2. [1208. Get Equal Substrings Within Budget](https://leetcode.com/problems/get-equal-substrings-within-budget/)
	1. right into window increase cost
	2. left out of window if bigger than maxCost
	3. update res
3. [904. Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/)
	1. find the longest subarray which only has two type of nums
	2. need hash map to keep track of two types
	3. left into window (add to counter)
	4. while counter len > 2
		1. left out of window and update counter
	5. update res
4. [2958. Length of Longest Subarray With at Most K Frequency](https://leetcode.com/problems/length-of-longest-subarray-with-at-most-k-frequency/)
	1. frequency -> hash map
	2. each freq <= k is valid
	3. right into window to add in counter
	4. while right freq > k
	5. left out of window to remove left in counter
	6. update res
5. [2024. Maximize the Confusion of an Exam](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/)
	1. max len with same answer
	2. k is the num we can replace
	3. right into window, add count
	4. while min ans > k
	5. left out of window, decrease count
	6. update res
6. [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)
	1. find max consecutive 1s
	2. can flip 0s k times
	3. keep track of num of 0s
	4. right into window
		1. if 0, track
	5. while 0s > k
	6. right out of window till hit a 0 and decrease zero
	7. update res
7. [1658. Minimum Operations to Reduce X to Zero](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/)
	1. find the min num of operations to reduce x to 0
	2. flip the question to be
		1. find the max num of subarray to add to sum - x
	3. target = sum(nums) - x
	4. return -1 if target < 0
	5. right into window to add to sum
	6. while sum > target
	7. left out of window to decrease sum
	8. update res if == target
	9. return n - res
8. 